#+title: Djupinlärning av 3-SAT

* Anteckningar
  
** Förklara orden/förklara:
   Modul, dimension av vektor, vektorkomponent, list (python), parametrar
   till en funktion (python), funktionparameter på följande vis: f(arg1, arg2)
   Rectifier, Sigmoid, objekt orienterade termer (objekt och metod), softmax, 
   Stokastiskt gradient nedgång, append (python)
   
** Fixa:
   Att jag har skrivit numpy.funktion men bör bara konsekvent med np.funktion
   instället

** Figurer:
   Neuralt nätverk

** Referenser:
   Att 3-sat är ett NP problem och alla NP problem är ekvivalenta.

* Abstract
  Many important problems such as protein folding, circuit design
  and breaking RSA encryption all fall under the complexity class NP. For
  many of these problems, the finding of a polynomial time algorithm would
  be greatly appreciated. Better circuit design would improve computing speed
  and faster protein folding could lead to a cure for cancer. But for problems
  such breaking RSA encryption, a polynomial time algorithm would not be as much
  appreciated as it would cause online banking to easily be hacked. If a
  polynomial time algorithm would be found to the 3-SAT problem it would also
  apply to all problems in the complexity class NP. A polynomial time algorithm
  to 3-SAT, or simply a proof of the existence or non-existence of one is yet
  to be found. Recently, advances in machine self-learning with the use of neural
  networks has lately shown much succes. Self taught AIs can now outperform 
  humans in many advanced games such as DOTA and Go. In this paper, 
  neural networks are trained to solve 3-SAT problems with fixed variable length
  in order to see what the results sugests regarding the finding of a 
  polynomial time algorithm.
* Inledning
  Många problem som datorer försöker lösa kan delas upp i två klasser: P och NP.
  P kan anses som problem som kan lösas "snabbt" ("snabbt" defineras i teori). 
    Problem som faller under
    denna kategori är exempelvis multiplikation och att sortera namn i
    alfabetsordning. Om man definerar P som problem som kan lösas "snabbt" så är
    NP problem som man kan kontrolera om ett svar är korrrekt "snabbt". Ett 
    exempel
    på detta är att primtals faktorisera. Om jag skulle fråga dig, läsaren att
    hitta delare till talet 2231 med endast penna och papper så skulle det nog
    tag ganska lång tid. Den enda metod du skulle ha förutom att använda
    delbarhetstester är att kolla varenda nummer lägre än 2231 och testa att 
    dela. Men om jag istället bad dig att kolla om svaret är 23 och 97 så 
    skulle det bli enklare. Då kan du helt enkelt ställa upp 23 gånger 97 
    och se om det blir 2231. Problemet anses vara i NP för att svaret kunde
    kontroleras "snabbt".
    

    I klassen NP så finns det en delmängd problem som kallas NP-fullständiga.
    NP-fullständiga problem är problem vars lösningsalgoritm kan användas för
    varenda problem i hela klassen NP. D.v.s det räcker att du hittar en "snabb"
    lösning för ett problem som är NP-komplett och då kan du lösa varenda problem
    i NP snabbt. Ett problem som faller under klassen NP-fullständiga problem är
    3-SAT, som är enkel att formulera matematisk då det inte primärt grundar
    sig på ett problem i verkligheten.
    
    
** Syfte och Frågeställning
   I detta arbete beskrivs skapandet av data som innehåller lösta 3-SAT problem 
   som kan användas för träningen av ett neuralt nätverk. Sedan beskrivs 
   konstruktionen av modellen för det neurala nätverket samt träningen av det
   nätverket med hjälp av den skapade datan. Syftet med denna uppgift är att 
   utforska frågan om hur bra neurala nätverk kan lösa 3-SAT problem för att
   nyansera frågan om en algoritm som löser 3-SAT i polynomisk tid är möjlig.
   Texten har också i syfte att undervisa om hur python fungerar i samband
   av matematiska undersökningar. 
* Teori
** Propositionell logik
** Linjär algebra
*** Vektor
*** Matris
*** Matris vektor multiplikation
** Deep learning
*** Bildlig förklaring
    Ett neuralt nätverk är trots dess komplex struktur i grunden en funktion.
    Det tar in data och och ger ut ett svar. Det som gör det speciellt
    är att man har efterliknat modellen till hur hjärnan fungerar,
    och den är gjord att lära sig på samma sätt männsikor lär sig:genom att
    träna sig igenom exempel. Nätverket består av noder som är ordnade i lager.
    Varenda nod i det vänstra lagret är kopplad till varenda nod i lagret
    till höger om sig, som i sig förhåller sig likadant till lagret till höger om sig
    (se figstuff). 

    Om man kollar i detalj på en nod så ser man att varje 
*** Linjär algebra
*** Flervariabel analys
**** Funktioner av flera variabler
**** Paritalderivata
**** 
** Grunderna till python och programering
*** Programmering
    Programering är ett sätt att skriva instruktioner för vad en dator
   ska göra. Programmering utförs genom att skriva på ett "låtsas" språk
   i en textfil. Sedan låter man datorn översätta textfilen direkt till ett 
   program eller så låter man ett "tolk" program tolka instruktionerna i 
   textfilen och utföra de direkt. "Låtsas" språk kallas mer formellt som
   programspråk. De programspråk som kan översättas från en textfilen till ett 
   program kallas kompilerade programspråk; De programsspråk där intruktionerna 
   i textfilen tolkas direkt kallas interpreterade programspråk (fixa hänvisning 
   här refA). 
*** Python
    Python är ett interpreterat programspråk. Detta är i fördel vid vetenskaplig
    programmering då man kan snabbt få resultat och inte behöva vänta på att
    koden kompileras. Instruktioner i python (och allmänt i programmering) ges
    genom att skriva funktioner. Funktioner i programmering är väldigt lika 
    till funktioner i matematik, men inte helt ekvivalenta. Funktioner i
    python kan likt matematiska funktioner ta in ett tal och utföra någon 
    operation och sedan mata ut det nya talet. Men den stora skillnaden är att
    en funktion i programmering kan också utföra ett moment. Detta kan vara
    att spara något i minnet, skicka ett medelande eller starta ett program. 
    Tillskillnad från matematik, där funktioner betecknas med enstaka bokstäver,
    så betecknas funktioner i programmering med ord eller mindre
    meningar där varje ord är separerad med understreck. Den mest fundementala
    och viktigaste funktionen vid lärning av  grunderna i python är funktionen "print". 
    Funktionen talar om för tolkprogrammet att visa dess argument. Betrakta
    följande kod:

   
    
#+BEGIN_SRC python
print(5) 
#+END_SRC

    En femma visas då i tolkprogrammet som konsekvens. Python kod utförs 
    uppifrån nedåt i ordning rad för rad. Så om man skriver

#+BEGIN_SRC python
print(5)
print(4) 
#+END_SRC

    så kommer det först stå en femma och sedan stå en fyra. Python räknar ut
    och förenklar automatiskt matematiska uttryck.

#+BEGIN_SRC python
print (9+10) 
#+END_SRC

     Resultatet av ovanstående kod blir då 19 och inte "9+10". Om man vill
     bokstavligt skriva ut symbolerna nio, plustecken, etta och nolla så 
     omringar man uttrycket med citattecken.

#+BEGIN_SRC python
print ("9+10") 
#+END_SRC


      Resultatet av ovanstående kod blir då "9+10" tillskillnad från koden innan.
      Värden kan sparas i variabler.
kodkolla
#+BEGIN_SRC python
  number = 2+2
  text = "10+20+30"

  print(number)
  print(text) 
#+END_SRC

      Eftersom python kan krångla om man använder de svenska bokstäverna
      'åäö', så kommer kod i fortsättningen skrivas på engelska. Till varje
      variabel finns det en associerad typ. Variabeln number i det tidigare
      exemplet har typen int, förkortning för ordet integer, d.v.s typen
      för heltal. Variabeln text har typen str, förkortning för string, 
      för att syfta på att det är en sträng symboler som tolkas bokstavligt.
      Det är viktigt om man ska t.ex. plusa ihop två variabler, att de är
      av samma typ.

#+BEGIN_SRC python
number = 10
text = "10"

print(text + text)
#+END_SRC

      Ovanstående kod ger ett felmedelande då python ser text variabeln
      som en sammling symboler och vet inte hur man lägger ihop dem med ett
      nummer. Det är dessutom viktigt att förstå att fast det är ett likamed
      tecken så ska man tolka det mer som att det som är på högersida läggs
      in på vänster sida. Om man väl har samma typ så har operationen plus
      olika betydelse.

#+BEGIN_SRC python
number = 10
text = "10"

print (number + number)
print (text + text) 
#+END_SRC

      Som man ser så utförs den matematiska operationen plus då variablerna 
      är av type int. Om de är av typen str så läggs de symbolerna ihop.


#+BEGIN_SRC python
x = 5
x = x + 10 
print (x)
#+END_SRC

      Den andra raden ser ut som ett felaktigt matematisk uttryck. Men det som
      sker är att första raden läses och python lägger in värdet 5 i variabeln x.
      Sedan läses andra raden och x + 10 räknas ut och sedan läggs det nya 
      värdet in i x. 
*** Funktioner och loops
      Som sagt så kan funktioner i python fungera som vanliga matematiska funktioner.
      Om man vill programmera funktionen

#+BEGIN_SRC latex
\[
f(x) =  3x^2 + 4x + 5 
\]
#+END_SRC

      så skriver man

#+BEGIN_SRC python
def f(x):
  return 3 * x**2  +  4 * x  + 5

value = f(5)
print (value)
#+END_SRC

      En stjärna betyder då multiplikation och två stjärnor betyder upphöjt.
      Men som det har tidigare nämnts så kan funktioner i python utföra 
      moment. Om man vill visa texten "Hello world" och sedan resultatet av
      2+2 på skärmen, så kan man definera funktionen

#+BEGIN_SRC python
def f():
  print ("Hello world")
  print (2+2) 
#+END_SRC

      Som man ser i ovanstående kod så behöver funktionen inte ta
      några variabler som argument tillskillnad från riktiga variabler. 
      Man behövde dessutom inte skriva return då denna funktion enbart
      utförde något och inte gav tillbaka ett värde. En annan viktig observation
      är att alla instruktioner som tillhör funktionen är indenterade.

      Som det har tidigare 
      nämnts så är det mer korrekt enligt stilguiden att namge funktioner
      och variabler som ord eller meningar separerade med understreck. Så 
      funktionen $f$ skulle kunna namnges som
     
#+BEGIN_SRC python
def do_something():
  print ("Hello world")
  print (2+2)
#+END_SRC

       vilket är mer korrekt, även om de gör exakt samma sak.
       Om man vill repetera någonting så kan man skriva som följande. Dock om
       man skulle köra denna kod så skulle inget ske. Detta är p.g.a att 
       koden endast förklarar vad funktionen do_something gör men utför aldrig
       den. För att utföra den så måste man skriva ut funktionen på en rad.
       
#+BEGIN_SRC python
def do_something():
  print ("Hello world")
  print (2+2)

do_something() 
#+END_SRC


        För att repetera någonting skriver man som följande.

#+BEGIN_SRC python
for number in range(0,4):
  print(number) 
#+END_SRC

      Observera att variabeln number börjar på 0 går sedan igenom alla heltal 
      lägre än fyra, men aldrig fyra i sig själv. 

*** Moduler och något om objekt
    
    Många användbara funktioner som är svåra att
    programmera har redan blivit kodade. Många av dessa
    finns tillgängliga till allmänheten genom moduler. En modul är
    en sammling funktioner och variabler man kan enkelt
    importera i sin egen kod. Antag att det finns en modul 
    som heter Volumecontrols och har funktionen mute_volume. Givet att man 
    har instalerat modulen på sitt system så kan man importera modulen och 
    använda funktionen genom att skriva:

#+BEGIN_SRC python
import Volumecontrols

Volumecontrols.mute_volume() 
#+END_SRC

    Man skriver alltså modulens namn och ett punkttecken och sedan namnet på
    funktionen. Men det kan bli jobbigt att jämnt skriva modulnamnet "Volumecontrols"
    jämnt så då kan man importera modulen med ett smeknamn genom:

#+BEGIN_SRC python
import Volumecontrols as vc

vc.mute_volume() 
#+END_SRC

     Många moduler används med objekt orienterad programmering. Objekt orienterad
     programmering är användingen av objekt. Ett objekt är en variabel som har
     associerade funktioner och värden. Dessa funktioner, och värden
     kan nås (likt moduler) genom att skriva namnet på objektet sedan ett 
     punkttecken, och sist namnet på värdet eller funktionen. Ett objekt skapas 
     genom att skriva namnet man vill ge på objektet på vänster sida av ett 
     likhetstecken och sedan en funktion som skapar objekt på höger sida.
     
#+BEGIN_SRC python
name_of_object = object_creating_method() 
#+END_SRC

     Så om man fortsätter på exemplet med låtsas modulen Volumecontrols
     så kan man tänka sig att Volumecontrols kan skapa objekt för olika enheter
     som kan spela ljud i hemmet, t.ex sin tv eller dator. Och om man har
     objeketet my_tv så kan man t.ex öka ljudet på sin tv med funktionen
     my_tv.increase_volume(), och så kan man se vilken nivå på ljudet med
     my_tv.volume. Så om man vill skriva ett program som visar volymen på
     sin tv och sedan ökar den kan se ut som följande.

#+BEGIN_SRC python
import Volumecontrols as vc
my_tv = vc.create_object(96896)
print (my_tv.volume)
my_tv.increase.volume() 
#+END_SRC

      Så den första raden är importeringen av modulen. I den andra raden
      skapas objektet. I detta exempel så tar funktionen som skapar objektet
      ett nummer. Detta symbolisera någon sorts ID på sin tv, så
      my_tv blir just den TV man syftar på. På tredje raden visas volymen my_tv
      har och på fjärde raden ökas volymen på my_tv.
      
      Ett exempel på en typ som har objekt funktioner är list. En list är vad
      som det låter, en lista. En lista omringas av hakparanteser och elementen
      seprareras av kommatecken. Så om man vill en lista där första elementet
      är en siffran 9, andra är siffran 8, och tredje 7 så skriver man som följande

#+BEGIN_SRC python
my_list = [9,8,7] 
#+END_SRC

      Om man vill lägga till ett element kan man använda objektmetoden append.

#+BEGIN_SRC python
my_list = [9,8,7]
my_list.append(5)
print(my_list) 
#+END_SRC

*** figstuff
    refA

* Metod
** Skapandet av datan
*** Krav på datan
    Oavsett hur man bygger upp det neurala nätverket så behövs det
    data med exempel som är redan lösta. I detta arbete är syftet se om
    ett neuralt nätverk kan avgöra om ett 3-SAT problem är satisferbart
    eller inte. Alltså ska inputen vara ett 3-SAT problem och outputen vara
    en indikation på om det är satisferbart eller inte. För konstruktion
    av de neurala nätverk kommer modulen Tensorflow användas. Med den modulen
    krävs det att man har två listor: en för inputen och en för outputen. Alltså
    kommer första exemplets formell vara första elementet i inputlistan och
    svaret kommer vara första elementet i outputlistan. I detta arbete valdes det
    60 000 träningsexempel och 10 000 utvärderingsexempel. Träningsexempelerna
    är de exempel det neurala nätverket kommer analysera och anpassa sig efter.
    Utvärderingsexemplerna är de som kommer användas i betygsättning av hur
    bra nätverket fungerar. Anledningen varför dessa måste vara separata är att
    det är väldigt enkelt för neurala nätverk att endast memorera exemplerna
    som användes vid träningen. Därför krävs det att exempelerna är unika
    så att inget exempel i träningsdatan finns dessutom i utvärderingsdatan.

    Ett annat krav är att inputen och outputen är i form av en vektor av
    reella värden. Detta är inte ett problem för outputen då man kan ha en
    2 dimensionell vektor där första värdet är sannolikheten att formeln är
    falsk och andra värdet är sannolikheten att den är sann (se exempel1). En
    lika tydlig lösning för inputen finns dock inte. Ett förslag är att 
    associera ett värde till varje tecken och sedan låta antalet tecken
    beteckna dimensionen på vektorn (se exempel2). Som man dock ser i exempel
    (k0lla om det är två eller 2) två så är dimensionen av vektorn onödigt stor
    då vissa tecken har alltid samma värde. De enda tecknen som kan vara olika
    är variablerna. I denna text kommer detta faktum utnyttjas, då antalet 
    variabler i uttrycket kommer motsvara dimensionen av vektorn. 
    
    # Ett annat krav är att andelen sanna och falska formler fördelar sig lika.
    # Om ett svar skulle överväga så skulle nätverket kunna ställa in sig på att
    # endast svara det som är i majoritet. Detta är ett problem eftersom 
    # indikationen på om nätverket faktiskt gör någonting är att precisionen
    # är högre än en gissning. En gissning i det här fallet är 50% då det finns
    # två utfall. Antag t.ex. att det finns 

**** Figurer till parent sektion:
     exempel1, exempel2

*** Omvandling av 3-SAT formler
    Låt variablerna i en formel ordnas i viss order, exempelvis alfabetsordning
    och sedan stigande i nummer index. Den första variabeln kommer motsvara
    värdet 1, den andra 2, den tredje 3 o.s.v. Sedan när man har kodat för
    den sista variabeln med värdet $n$ så låter man $n+1$ symbolisera
    negationen av den första variabeln och $n+2$ negationen för den andra
    variabeln o.s.v. Sedan låtes det första variabeltecknet i formeln koda 
    för första värdet i vektorn och den andra den andra värdet 
    o.s.v. (se exempel3).

    I denna text kommer det dessutom begränsas till max 5 olika variabler
    i varje formel. Därmed så kan varje heltal (om man tar hänsyn till ledande
    nollor) symbolisera en unik formel (se exempel4). Detta löser nästan
    problemet om att skapa 60 000 träningsexempel och 10 000 utvärderingsexempel
    som är alla unika. Eftersom varje heltal motsvarar en unik formel så kan man
    låta de talen från 0 till och med 59 999 koda för träningsexempelarna 
    och talen 60 000 till 69 999 koda för utvärderingsexempelarna. Dock, somsagt
    löser detta nästan problemet. Första problemet är att om man ska ha fem 
    stycken värdesiffror så kommer formelerna vara fem variabler långa. Men 
    ett 3-SAT problem är på formen av en konjuktion av disjuktioner av längden
    tre variabler. Därför måste antalet variabler vara lika med en multipel 
    av tre. Det andra problemet är att formeln är kort och när en formel 
    är kortare så är det mindre chans att det blir en falsk formel (om man 
    antar att antalet olika variabler håller sig konstant). Anledningen är att
    fler konjuktioner begränsar antalet möjliga lösningar (om antalet variabler
    håller sig konstant). Ett exempel på detta ges i (exempel5).
    
    Lösningen på detta är att införa slumpmässiga siffror efter. På detta vis
    kommer alla exempel vara unika, och längden kan anpassas till en multipel
    av tre. I denna text kommer längden vara 72 variabler d.v.s fem bestämda
    siffror och 67 slumpmässiga.

**** Figurer till parent paragraf:
     exempel3, exempel4, exempel5

*** Simple-Sat
    Simple-sat är en 3-SAT lösare kodad av Sahand Saba, och används i detta
    arbete under MIT lisens. Den tar in en input i string format där varje
    konjuktion är separerad med ett komma och disjuktioner är separerade med 
    ett mellanslag.Så en variabel kan vara vilken kombination av bokstäver och
    siffror så länge det inte innehåller ett mellanslag. Det innebär att
    till skillnad från programspråk som python så kan en enkel siffra vara en
    unik variabel. Detta är i fördel till omvandlingen i denna metod eftersom
    varje siffra kodar en viss variabel. För att beteckna negationen används 
    tecknet tilde (~) framför variabeln utan mellanslag. Betrakta exempelA.

    Problemet med detta program är att det kan endast bli tillkallad i en terminal.
    En terminal är ett helt textbaserat program som man kan skriva in kommandon
    till för att starta olika program. De främsta operativsystemen är egentligen
    en terminal som kör i bakgrunden och det grafiska användargränsnitt
    man har tillgänglig är ett program som körs genom terminalen. Om man använder
    windows så heter terminalprogrammet "CMD", på Ubuntu heter (den som ingår)
    bash. 3-SAT programmet är gjort för terminaler under operativsystem Linux.
    Så två problem måste lösas. Det första problemet är att omvandla en string av 
    siffror till en formel som 3-SAT programet kan tolka. Det andra problemet
    är hur man ska kunna intargera med detta program genom python, då programet
    är gjord för att användas i en terminal i linux.

    
   
**** fig stuff
     exempelA

*** Omvandling till formel
    För att omvandla en string av siffror till en string i det format 3-SAT
    programmet tar emot definerar vi funktionen generate_formula. Generate
    formula tar argumentet *seed* som är stringen av siffror. Funktionen inleds
    med att definera två variabler.

kodA
#+BEGIN_SRC python
digits = seed
formula = []
disjunct_counter  = 0
#+END_SRC

    Seed döps om av den enkla anledningen att det kommer hjälpa med tydlighet
    i en loop som kommer senare. Formula variabeln är där alla tecken till
    formeln kommer läggas till. Vid slutet av programmet kommer elementen i 
    formula sättas ihop till formel stringen, men eftersom man har mer 
    kontroll med listor, defineras den som en tom lista i början. Variabeln
    disjunct_counter räknar antalet variabler d.v.s siffror i stringen. Detta
    behövs eftersom vid varje tredje variabel läggs det till en konjuktion, eller
    i fallet av denna 3-SAT lösare ett komma.

    Nästa del är att gå igenom varje siffra i digits och utföra ett av två fall och
    eventuellt ett specialfall. Specialfallet är när disjunct counter är multipel
    av tre. Då vill man lägga till ett komma och ett mellanslag. Så den första
    if klasulen är:

kodB
#+BEGIN_SRC python
if disjunct_counter % 3 == 0:
   formula.append(",")
   formula.append(" ")
#+END_SRC

    Det finns dock ett problem med denna kod. Noll är ju också en multipel av
    tre och det innebär att ett komma och ett mellanslag kommer läggas till
    i början av loopen då disjunct_counter börjar på noll. Så därför lägger
    vi till kravet att disjunct_counter är dessutom inte lika med noll.
    
kodC
#+BEGIN_SRC python
if disjunct_counter % 3 == 0 and disjunct_counter !=0:
   formula.append(",")
   formula.append(" ")
#+END_SRC

     Sedan så finns det ett av två fall som alltid kommer ske exklusivt. Det ena
     är att siffran är lägre än fem och den andra är att siffran är högre eller
     lika med fem. Om siffran är lägre än fem så vill man lägga till siffran
     och ett mellanslag till formula listan. Om siffran är högre så vill man 
     lägga till tilde och en nolla om det är fem, tilde och en etta om det är sex
     o.s.v. Alltså vill man därmed lägga till tilde och siffran minus 5, samt ett
     mellanslag. Dessa två fall kan skrivas som följande:
     
kodD
#+BEGIN_SRC python
if int(digit)<5 :
    formula.append(str(digit))
    formula.append(" " )
else:
    formula.append("~")
    formula.append(str(int(digit)-5))
    formula.append(" ")
#+END_SRC

     Anledningen varför man lägger till str(digit) och inte bara digit är 
     eftersom digit är av typen Int. För att kunna sätta ihop listan formula
     så behövs det att alla element är av typen String. Funktionen str tar
     siffran och ger tillbaka samma siffra fast med typen String. För att
     sedan få funktionen att ge tillbaka formeln fast som en string skriver man:

kodE
#+BEGIN_SRC python
return "".join(formula) 
#+END_SRC

      Funktionen "".join kanske ser märkligt ut först men det är helt enkelt
      en funktion som tar en lista och ger tillbaka en string där varje element
      är ihopsatt. Anledningen för den märkliga syntaxen är att det som är
      emellan citattecknena är det som kopplar ihop elementen, betrakta exempelA.
      Eftersom det inte ska vara något emellan elementen i listan formula
      så skrivs det ingenting mellan citattecknena och därmed skrivs det "".join.

      Så funktionen i helhet ser ut som följande.
kodF
#+BEGIN_SRC python
def generate_formula(seed):
   """Generates a formula that can be checked with the check function.
   """
   digits = seed
   formula = []
   disjunct_counter  = 0

   for digit in digits:
       if disjunct_counter % 3 == 0 and disjunct_counter != 0:
           formula.append(",")
           formula.append(" ")
       if int(digit)<5 :
           formula.append(str(digit))
           formula.append(" " )
           if debug:
               print ("borde vara under 5: " + str(digit))
       else:
           formula.append("~")
           formula.append(str(int(digit)-5))
           formula.append(" ")
           if debug:
               print ("borde vara over 5: "+ str(digit))
       disjunction_counter += 1

   return "".join(formula)
#+END_SRC

**** Figurer och sånt
     kodA, kodB, kodC, exempelA, kodD, kodE
*** Satisferbarhet av formeln
    För att få tillgång till att skicka kommandon till terminalen via python 
    använder man modulen Subprocess. Funktionen subprocess.check_output tar 
    in som argument ett terminal kommando ger tillbaka resultatet av vad som 
    skrevs i terminalen. Dock så tar funktionen inte en string som input fast
    istället en lista som sedan läggs ihop till en string där varje element är
    separerad med mellanslag, se exempelB. För att tillkalla programmet i 
    terminalen skriver man: 
   
kodG
#+BEGIN_SRC bash
python simple-sat/src/sat.py -ti "String som innehåller formeln på rätt format" 
#+END_SRC

    Så om variabeln string innehåller formeln och om man vill spara formelns
    validitet i en variabel result i python, så skriver man:

kodH
#+BEGIN_SRC python
result = subprocess.check_output(["python", "simple-sat/src/sat.py", "-ti", string])
#+END_SRC

    Programmet 3-SAT ger tillbaka en string med info om vad den satisferbara 
    lösning är, om formeln är satisferbar. Om den inte är satisferbar ges en tom
    string tillbaka. Eftersom informationen om det är satisferbar eller inte är
    det enda som är relevant i skapandet av datan så räcker det att kolla om 
    outputen är tom eller inte. På grund av hur python hanterar strings så finns
    det två sätt att skriva en tom string : '' och b''. Mer info står i appendix.
    Funktionen ser då ut i sin helhet som följande:

kodI
#+BEGIN_SRC python
  def check(string):
     """Checks if a formula generated by the generate_formula method,
     can be satisfied or not.
     """
   result = subprocess.check_output(["python", "simple-sat/src/sat.py", "-ti", string])
   if result == "" or result == b'':
      return 0
   else:
      return 1

#+END_SRC

**** Figurstuff
     ExempelB, kodG, kodH, appendix sak
*** Algoritm
**** Algoritmen på en allmän nivå
     1. Skapa en tom lista för all träningsdata
     2. Skapa en tom lista för all utvärderingsdata
     3. Låt n = 0
     4. Omvandla n till en lista med 5 värden
     5. Skapa en lista med 67 slumpmässiga värden
     6. Sätt ihop listorna från 2 och 3 till en ny lista
     7. Lägg till listan från 8 i input träningsdata listan (1)
     8. Omvandla listan från  8 till en formel
     9. Kolla om formeln från 10 är satisferbar
     10. Om den är satiferbar lägg till en etta i output träningsdatan
     11. Om den inte är det lägg till en nolla i output träningsdatan
     12. Repetera steg 3 till 13 där n ökar med ett varje gång, tills n=69999
     13. Exportera datan
**** Algortimen i python kod
***** Numpy arrays
      För att översätta den allmänna koden till python så skulle det
      tekniskt gå att ha vanliga listor. Men p.g.a att det är så stora
      värden samt att vi vill senare kunna exportera dessa listor, så
      är det mer praktiskt att använda en modul som heter Numpy. Listor
      i numpy heter "numpy arrays". Numpy arrays fungerar i omfattningen
      av denna text i princip som vanliga lists. Enda skillnaden är att
      det inte går att direkt modifera dem. Om man vill ändra en variabel
      som innehåller en numpy array så måste man skapa en ny array baserad 
      på den gamla och sedan spara den nya i variabeln (betrakta kod1). För 
      att skapa en numpy array använder man funktionen numpy.array. Som 
      argument sätter man i en vanlig list som numpy arrayen kommer efterlikna. 
      Betrakta kod2.
      
      kod2 (eller 1?)
     #+BEGIN_SRC python
       import numpy

numpy_array = numpy.array([4,2,0])
#+END_SRC


      Fotnot till kod2: Det är två paranteser p.g.a att man kan sätta in
      flera parametrar och de arrays man vill lägga ihop sätter man in
      i första parametern.

      
      En sak man måste ta i hänsyn med numpy är att man måste specifiera vid
      skapandet av en array vad för typ alla element kan vara. Man kan därmed
      inte ha olika typer. Detta i kontrast till vanliga listor som man kan 
      ha flera olika typer. Betrakta exempel6 där listan av sig själv fungerar
      men om man omvandlar till en numpy array skapas det ett felmedelande. 
      Man kan dock skapa en tom arrray och lägga till värden, så detta är inte
      ett problem för ouputdatan. Men för input datan så har man en sammling av
      listor av storleken 72. Om man skulle skapa en tom numpy array 
      och en numpy array med 72 element och sedan försöka använda numpy.concatenate,
      visas ett felmedelande. Man är då tvungen att vid skapandet av numpy arrayen
      för träningsdata redan ha ett element som är en numpy array på storleken 72.
      Ett enkelt sätt att göra detta är med funktionen numpy.zeros. Numpy.zeros
      tar in en storlek som argument och skapar en numpy array fylld med nollor
      med den specifierade storleken. För att skapa en array med 5 nollor skriver
      man numpy.zeros(5). För att skapa en array fylld med 3 arrays där varje
      array har 2 nollor skriver man numpy.zeros((3,2)) (se kod3). 

      Eftersom träningsdatan kommer vara en array där varje element är
      en array på 72 element, så skriver man numpy.zeros((1,72)). Ett problem
      som uppstår på grund av detta är att första träningsexemplet kommer vara
      på plats två och det andra på plats 3 o.s.v (se figur1). Detta löses dock 
      enkelt genom att ta bort det första elementet i slutet av algoritmen. Man
      kan göra detta med funktionen numpy.delete. En sista detalj är att
      koden så betecknas input med x och output med y. Notationen är inte för
      någon speciell anledning, för att det ska bli enklare att skriva
      variabeln. Så steg 1 och två kan översättas till följande kod:

#+BEGIN_SRC python
  import numpy as np

  x_train = np.zeros((1,72))
  y_train = np.array([])
#+END_SRC
***** Loopen steg 3 till 7
      Nästa del i koden är att påbörja loopen från steg 3 till 12. Första steget
      i loopen är att omvandla n till en lista med fem värdesiffror. För det
      första så är det mer korrekt enlight pythons rekomederade stilformat att
      ha ord istället för bokstäver som variabler, så n kommer reffereras som num
      i python koden. Omvandlingen av num delades upp i fyra delar. Först
      omvandlades num till en String. Sedan lades det eventuellt på ledande 
      nollor för att få Stringen att ha 5 värdesiffror. Sedan omvandlades den
      till en vanlig lista, och tillsist en numpy array. Steg 1 och 2 blev en rad
      och steg 3 och 4 blev också en rad. Koden såg ut som följande:
      
      kod4
#+BEGIN_SRC python
num_string = str(num).zfill(5)
head_array = np.array(int_list(num_string))
#+END_SRC

      Steg 5 skrevs på följande vis:

kod5
#+BEGIN_SRC python
tail_array = np.random.randint(10, size=67)
#+END_SRC

      Första argumentet anger då att alla heltal under det givna nummret
      får slumpmässigt skapas, och size parametern talar om för storleken av
      arrayen som skapas. 

      För att sedan lägga ihop de två arraysen används np.concatenate.

kod6
#+BEGIN_SRC python
array_to_append = np.concatenate((head_array,tail_array))
#+END_SRC

      Sedan för att lägga till denna array till träningsdatan använder
      np.concatenate för att updatera x_train.

kod7
#+BEGIN_SRC python
x_train = np.concatenate((x_train, [array_to_append]))
#+END_SRC

      
****** Figurer
       Kod1, Kod2, exempel6, kod3, figur1, kod4, kod5, kod6, kod7

***** Loppen steg 8 till 11
     För att se om formeln är satisferbar eller inte används en 3-SAT lösare 
     programerad av Sahand Saba under MIT licens. Sabas program körs egentligen
     via terminalen, men den är tillgänglig med modulen satsolver.py som finns
     beskriven i appendix I. Modulen innehåller två funktioner:
     satsolver.generate_formula och satsolver.check. Satsolver.generate_formula
     tar en numpy array och omvandlar den enligt metoden beskriven i omvandling
     av 3-sat, till en formel satsolver.check kan ta som argument. Satsolver.check
     ger då värdet noll om formeln är ej satisferbar och värdet ett om 
     den är satisferbar. Så koden blir som följande:
     
kod8
#+BEGIN_SRC python
formula = sat.generate_formula(array_to_append)
value_to_append = sat.check(formula)
y_train = np.append(y_train, value_to_append)
#+END_SRC

      Ett steg som inte står beskrivet i den allmänna algortimen, är att 
      radera det elementet i x_train. Detta var som sagt p.g.a vid skapandet
      av x_train behövdes ett element fylld av nollor som specifierade storleken
      på arrayen. Så för att radera det första elementet i x_train används
      följande kod:

kod9
#+BEGIN_SRC python
x_train = np.delete(x_train, 0, 0)
#+END_SRC




****** Figurer, kod och referatmarkörer
       Sahanda Saba, referens till omvandling av 3-sat, kod8, kod9
***** Export av datan
      För att exportera numpy arrays används funktionen np.save. Funktionen tar
      in namnet på en filplats och numpy arrayen man vill spara. I detta projekt
      så sparades filerna i mapp kallad 'data'. Så exporterings koden såg ut som
      följande:
      
#+BEGIN_SRC python
np.save('data/x_train', x_train)
np.save('data/y_train', y_train)
#+END_SRC

****** Kod saker:
       ko10
***** Anpassning för utvärderingsdatan
      Koden för utvärderingsdata är i princip likadan. Enda skillnaden är att
      num fick variera mellan 60 000 och 69 999 och datan sparades som x_test
      och y_test för input datan respektive output datan.
** Skapandet av modellen
*** Representation av modellen
    Modellen består alltså av 10 lager med 128 noder var, där Rectifier är 
    aktiveringsfunktionen. Det finns dessutom ett till lager i slutet som 
    består av endast en nod och har Sigmoid aktiveringsfunktionen (se figur2).
*** Tensorflow och Keras
    För att skapa den här modellen i python används modulerna Tensorflow och 
    Keras. Tensorflow är en modul som tillåter en att bygga neurala nätverk från 
    grunden. Keras är en modul som som förenklar byggandet och träningen av 
    neurala nätverk. I koden kommer dessa moduler och delar modulerna importeras:

kod11
#+BEGIN_SRC python
import numpy as np
from tensorflow import keras
from tensorflow.keras.layers import Activation, Dense
#+END_SRC

    För att skapa en tom modell som man sedan kan senare tillägga fler lager till 
    skriver man:

kod12
#+BEGIN_SRC python
model = keras.models.Sequential()  
#+END_SRC

    Variabeln model blir då ett objekt som symboliserar det neurala nätverket.
    För tillägg av lager samt träning och utvärdering av modellen används
    assosierade objekt metoder. För att lägga till ett lager (till höger om
    man tänker som fig2 där input går in till vänster och output går ut från
    höger) så använder man objektmetoden add. Som argument tar den vad för
    sorts lager. Den sortens lager som har hittils gått igenom i texten kallas
    i keras för 'Dense'. Det är alltså ett lager som kan symboliseras med en 
    matris, eller noder på rad, samt en associerad aktivationsfunktion. Så för
    att lägga till ett lager med 128 noder, och Rectifier som aktiveringsfunktionen
    skriver man:

    kod13
#+BEGIN_SRC python
model.add(Dense(128, activation='relu'))  
#+END_SRC

    relu symbolisera då Recitifier funktionen. Den här raden av kod repeteras
    då 10 gånger så att det blir totalt tio lager. Sista lagret är två noder
    där första noden är sannolikheten att det är noll och andra är sannolikheten
    att det är 1. Detta görs med aktiveringsfunktionen "softmax". Följande kod
    motsvarar detta lager:
    
kod14
#+BEGIN_SRC python
model.add(Dense(2, activation='softmax'))
#+END_SRC

    


**** Saker
     kod11, kod12, figur2, kod13
** Träning av nätverket
   För träning av nätverket används "binary cross entropy" som loss funktion,
   'accuracy' som metric och stokastisk gradient nedgång som optimizer.
   'Binary crossentropy' och 'accuracy' förklaras ej i detta arbete men dokumentaion
   om dessa funktioner finns på [ref2]. För att träna nätverket och sedan
   utvärdera det skrivs följande kod:

kod15
#+BEGIN_SRC python
model.compile(optimizer = 'SGD', loss='binary_crossentropy', metrics=['accuracy'])
model.fit(x_train, y_train, epochs=5)
model.evaluate(x_test, y_test, verbose=2)
#+END_SRC

   Epochs är hur många gånger den går igenom all data. Så epoch 1 är första
   gången den går igenom datan epoch 2 andra gången o.s.v. Verbose variabeln 
   specifierar bara hur mycket information som printas ut. 

*** Stuff ref kod och sånt
    ref2, kod15
* Resultat
** Model 1
   | Epoch | tid        | resultat |
   |-------+------------+----------|
   |     1 | 8 sekunder | 50 %     |
   |     2 | 7 sekunder | 50 %     |
   |     3 | 7 sekunder | 50 %     |
   |     4 | 7 sekunder | 50 %     |
   |     5 | 7 sekunder | 50 %     |
   
   Och för träningsdatan var resultatet 50 %.
* Diskussion och slutsats
   Som man ser så var resultatet på samtliga delar av utvärderingsprocessen 
   50 %. Detta tyder med säkerhet att nätverket inte har hittat något mönster
   då det är lika med chansen för en gissning. Detta stödjer kontentan bland 
   forskare att P är skiljt från NP (ref3). Eftersom om det finns en tydligt 
   mönster som neurala nätverk kan se så skulle det öka chansen att det finns 
   en enklare algortim för 3-SAT problem av allmänn storlek, som är tillräckligt 
   enkel så att den är i polynomisk tid. Detta utesluter såklart dock inte att
   neurala nätverk kan tränas att lösa 3-SAT problem. På grund av att koden
   behövde köras på en persondator, så var antalet lager, noder, epochs, och
   träningsexempel begränsade till processorkraften och minnet tillgängligt.
*** Ref och sånt
    ref3
** Vidare forskning
*** Djupare nätverk

* Appendix
** I
