#+title: Djupinlärning av 3-SAT

* Anteckningar
  
** Förklara orden:
   Modul, dimension av vektor, vektorkomponent, list (python), parametrar
   till en funktion (python)

** Referenser:
   Att 3-sat är ett NP problem och alla NP problem är ekvivalenta.

* Abstract
* Inledning
** Bakgrund
** Syfte och Frågeställning
* Teori
** Propositionell logik
** Linjär algebra
** Deep learning
*** Bildlig förklaring
*** Linjär algebra
*** Flervariabel analys
** Introduktion till python
* Metod
** Skapandet av datan
*** Krav på datan
    Oavsett hur man bygger upp det neurala nätverket så behövs det
    data med exempel som är redan lösta. I detta arbete är syftet se om
    ett neuralt nätverk kan avgöra om ett 3-SAT problem är satisferbart
    eller inte. Alltså ska inputen vara ett 3-SAT problem och outputen vara
    en indikation på om det är satisferbart eller inte. För konstruktion
    av de neurala nätverk kommer modulen Tensorflow användas. Med den modulen
    krävs det att man har två listor: en för inputen och en för outputen. Alltså
    kommer första exemplets formell vara första elementet i inputlistan och
    svaret kommer vara första elementet i outputlistan. I detta arbete valdes det
    60 000 träningsexempel och 10 000 utvärderingsexempel. Träningsexempelerna
    är de exempel det neurala nätverket kommer analysera och anpassa sig efter.
    Utvärderingsexemplerna är de som kommer användas i betygsättning av hur
    bra nätverket fungerar. Anledningen varför dessa måste vara separata är att
    det är väldigt enkelt för neurala nätverk att endast memorera exemplerna
    som användes vid träningen. Därför krävs det att exempelerna är unika
    så att inget exempel i träningsdatan finns dessutom i utvärderingsdatan.

    Ett annat krav är att inputen och outputen är i form av en vektor av
    reella värden. Detta är inte ett problem för outputen då man kan ha en
    2 dimensionell vektor där första värdet är sannolikheten att formeln är
    falsk och andra värdet är sannolikheten att den är sann (se exempel1). En
    lika tydlig lösning för inputen finns dock inte. Ett förslag är att 
    associera ett värde till varje tecken och sedan låta antalet tecken
    beteckna dimensionen på vektorn (se exempel2). Som man dock ser i exempel
    (k0lla om det är två eller 2) två så är dimensionen av vektorn onödigt stor
    då vissa tecken har alltid samma värde. De enda tecknen som kan vara olika
    är variablerna. I denna text kommer detta faktum utnyttjas, då antalet 
    variabler i uttrycket kommer motsvara dimensionen av vektorn. 
    
    # Ett annat krav är att andelen sanna och falska formler fördelar sig lika.
    # Om ett svar skulle överväga så skulle nätverket kunna ställa in sig på att
    # endast svara det som är i majoritet. Detta är ett problem eftersom 
    # indikationen på om nätverket faktiskt gör någonting är att precisionen
    # är högre än en gissning. En gissning i det här fallet är 50% då det finns
    # två utfall. Antag t.ex. att det finns 

**** Figurer till parent sektion:
     exempel1, exempel2

*** Omvandling av 3-SAT formler
    Låt variablerna i en formel ordnas i viss order, exempelvis alfabetsordning
    och sedan stigande i nummer index. Den första variabeln kommer motsvara
    värdet 1, den andra 2, den tredje 3 o.s.v. Sedan när man har kodat för
    den sista variabeln med värdet $n$ så låter man $n+1$ symbolisera
    negationen av den första variabeln och $n+2$ negationen för den andra
    variabeln o.s.v. Sedan låtes det första variabeltecknet i formeln koda 
    för första värdet i vektorn och den andra den andra värdet 
    o.s.v. (se exempel3).

    I denna text kommer det dessutom begränsas till max 5 olika variabler
    i varje formel. Därmed så kan varje heltal (om man tar hänsyn till ledande
    nollor) symbolisera en unik formel (se exempel4). Detta löser nästan
    problemet om att skapa 60 000 träningsexempel och 10 000 utvärderingsexempel
    som är alla unika. Eftersom varje heltal motsvarar en unik formel så kan man
    låta de talen från 0 till och med 59 999 koda för träningsexempelarna 
    och talen 60 000 till 69 999 koda för utvärderingsexempelarna. Dock, somsagt
    löser detta nästan problemet. Första problemet är att om man ska ha fem 
    stycken värdesiffror så kommer formelerna vara fem variabler långa. Men 
    ett 3-SAT problem är på formen av en konjuktion av disjuktioner av längden
    tre variabler. Därför måste antalet variabler vara lika med en multipel 
    av tre. Det andra problemet är att formeln är kort och när en formel 
    är kortare så är det mindre chans att det blir en falsk formel (om man 
    antar att antalet olika variabler håller sig konstant). Anledningen är att
    fler konjuktioner begränsar antalet möjliga lösningar (om antalet variabler
    håller sig konstant). Ett exempel på detta ges i (exempel5).
    
    Lösningen på detta är att införa slumpmässiga siffror efter. På detta vis
    kommer alla exempel vara unika, och längden kan anpassas till en multipel
    av tre. I denna text kommer längden vara 72 variabler d.v.s fem bestämda
    siffror och 67 slumpmässiga.

**** Figurer till parent paragraf:
     exempel3, exempel4, exempel5

*** Algoritm
**** Algoritmen på en allmän nivå
     1. Skapa en tom lista för all träningsdata
     2. Skapa en tom lista för all utvärderingsdata
     3. Låt n = 0
     4. Omvandla n till en lista med 5 värden
     5. Skapa en lista med 67 slumpmässiga värden
     6. Sätt ihop listorna från 2 och 3 till en ny lista
     7. Lägg till listan från 8 i input träningsdata listan (1)
     8. Omvandla listan från  8 till en formel
     9. Kolla om formeln från 10 är satisferbar
     10. Om den är satiferbar lägg till en etta i output träningsdatan
     11. Om den inte är det lägg till en nolla i output träningsdatan
     12. Repetera steg 3 till 13 där n ökar med ett varje gång, tills n=69999
     13. Exportera datan
**** Algortimen i python kod
***** Numpy
      För att översätta den allmänna koden till python så skulle det
      tekniskt gå att ha vanliga listor. Men p.g.a att det är så stora
      värden samt att vi vill senare kunna exportera dessa listor, så
      är det mer praktiskt att använda en modul som heter Numpy. Listor
      i numpy heter "numpy arrays". Numpy arrays fungerar i omfattningen
      av denna text i princip som vanliga lists. Enda skillnaden är att
      det inte går att direkt modifera dem. Om man vill ändra en variabel
      som innehåller en numpy array så måste man skapa en ny array baserad 
      på den gamla och sedan spara den nya i variabeln (betrakta kod1). För 
      att skapa en numpy array använder man funktionen numpy.array. Som 
      argument sätter man i en vanlig list som numpy arrayen kommer efterlikna. 
      Betrakta kod2.
      
      kod2 (eller 1?)
     #+BEGIN_SRC python
       import numpy

numpy_array = numpy.array([4,2,0])
#+END_SRC



      Fotnot till kod2: Det är två paranteser p.g.a att man kan sätta in
      flera parametrar och de arrays man vill lägga ihop sätter man in
      i första parametern.

      
      En sak man måste ta i hänsyn med numpy är att man måste specifiera vid
      skapandet av en array vad för typ alla element kan vara. Man kan därmed
      inte ha olika typer. Detta i kontrast till vanliga listor som man kan 
      ha flera olika typer. Betrakta exempel6 där listan av sig själv fungerar
      men om man omvandlar till en numpy array skapas det ett felmedelande. 
      Man kan dock skapa en tom arrray och lägga till värden, så detta är inte
      ett problem för ouputdatan. Men för input datan så har man en sammling av
      listor av storleken 72. Om man skulle skapa en tom numpy array 
      och en numpy array med 72 element och sedan försöka använda numpy.concatenate,
      visas ett felmedelande. Man är då tvungen att vid skapandet av numpy arrayen
      för träningsdata redan ha ett element som är en numpy array på storleken 72.
      Ett enkelt sätt att göra detta är med funktionen numpy.zeros. Numpy.zeros
      tar in en storlek som argument och skapar en numpy array fylld med nollor
      med den specifierade storleken. För att skapa en array med 5 nollor skriver
      man numpy.zeros(5). För att skapa en array fylld med 3 arrays där varje
      array har 2 nollor skriver man numpy.zeros((3,2)) (se kod3). 

      Eftersom träningsdatan kommer vara en array där varje element är
      en array på 72 element, så skriver man numpy.zeros((1,72)). Ett problem
      som uppstår på grund av detta är att första träningsexemplet kommer vara
      på plats två och det andra på plats 3 o.s.v (se figur1). Detta löses dock 
      enkelt genom att ta bort det första elementet i slutet av algoritmen. Man
      kan göra detta med funktionen numpy.delete. Så steg 1 och två kan
      översättas till följande kod:

#+BEGIN_SRC python
import numpy as np

x_train = np.zeros((1,72))
y_train = np.array([])
#+END_SRC

      Nästa del i koden är att påbörja loopen från steg 3 till 12. Första steget
      i loopen är att omvandla n till en lista med fem värdesiffror. För det
      första så är det mer korrekt enlight pythons rekomederade stilformat att
      ha ord istället för bokstäver som variabler, så n kommer reffereras som num
      i python koden. Omvandlingen av num delades upp i fyra delar. Först
      omvandlades num till en String. Sedan lades det eventuellt på ledande 
      nollor för att få Stringen att ha 5 värdesiffror. Sedan omvandlades den
      till en vanlig lista, och tillsist en numpy array.
****** Figurer
       Kod1, Kod2, exempel6, kod3, figur1
**** Pythonkoden actually
** Model 1
** Model 2
** Träning av datan
* Resultat
** Model 1
** Model 2
* Diskussion och slutsats
** Sannolikhet att liknande (och därmed samma) sat formler fanns
